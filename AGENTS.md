
# AGENTS.md: StrategyQuant資金管理スニペットのMT4 MQL変換ガイド

StrategyQuant X (SQX)では、戦略の構築要素（インジケータ、シグナル、マネーマネジメントなど）をJavaで記述し、各プラットフォーム用のコードをテンプレートで生成します。特に「資金管理 (Money Management)」スニペットをMetaTrader4 (MT4)のエキスパートアドバイザ（EA）用MQL4コードに変換するには、SQXの3種類のテンプレートファイル（`_class.tpl`, `_method.tpl`, `_variables.tpl`）を用います。本ガイドでは、それぞれのテンプレートの役割、JavaコードからMQLコードへのプレースホルダ置換方法、コード例（Javaコードと生成されるMQLコードの比較）、命名規約やベストプラクティス、動的なSL/TPやロット計算時の注意点について詳細に解説します。また、これらテンプレートが最終的にMT4 EAコード内のどこに組み込まれるか、SQXでEAをエクスポートする際の統合上の留意点についても説明します。

## テンプレートファイルと変換プロセス概要

SQXでは、ユーザーが追加した新しいスニペットに対し、各対応プラットフォーム（MT4/MT5、他プラットフォーム）のコード生成用テンプレートを用意する必要があります。テンプレートファイルは拡張子`.tpl`を持ち、Freemarkerテンプレートエンジンによってスニペットの定義（内部ではXML形式）からターゲット言語のコードへ変換されます。つまり、テンプレートにはターゲット側で**実行**されるロジックそのものではなく、**ターゲットの組み込み関数呼び出し**やコード断片が含まれており、これを組み合わせることで最終的なEAコードが構成されます。資金管理スニペットの場合、Javaの`computeTradeSize`メソッドで定義されたロット計算ロジックを、MT4のEA内で同等の処理を行うコード片に翻訳する必要があります。そのために以下の3つのテンプレートファイルを用います。

* **`<SnippetName>_class.tpl`** – クラス定義や関数定義など、EAのグローバル領域に追加するコード片を定義します。
* **`<SnippetName>_method.tpl`** – 実際にロット数を計算するロジック（`computeTradeSize`相当）をEAの処理フローに挿入するコード片を定義します。
* **`<SnippetName>_variables.tpl`** – 資金管理スニペットで使用するパラメータや変数をEAのグローバル変数（入力パラメータ等）として宣言するコード片を定義します。

以下、それぞれのテンプレートについて役割・構文・プレースホルダとJavaからMQLへのマッピング・コード例・ベストプラクティス/注意点を詳述します。

## `_class.tpl` – クラスレベルコードの定義

### 役割と概要

`_class.tpl`は、資金管理スニペットに関連する**クラスレベルのコード**を提供するテンプレートです。ここでいう「クラスレベルのコード」とは、EAのグローバル領域に追加される関数定義や静的変数、場合によってはクラス定義そのものを指します。MQL4のEAは基本的に手続き型コードで記述されますが、SQXではプラットフォーム間でテンプレートの構造を統一するため、資金管理スニペットに関する処理を論理的に分離し、この`_class.tpl`に**ヘルパー関数**や**共通処理**として実装することがあります。

例えば、資金管理ロジックが複雑な場合や再利用される計算がある場合は、このテンプレートで独自関数を定義し、それをEA内で呼び出すようにします。シンプルなロジックであれば、MQL4では関数を分けず直接`_method.tpl`内で記述しても構いませんが、コードの見通しや他プラットフォームとの整合性のために`_class.tpl`を用意します。

### 構文とプレースホルダの使い方

`_class.tpl`内では、Freemarkerの標準構文およびSQXで定義されたマクロを使用してコードを生成します。他のテンプレート同様、スニペットのプロパティ（パラメータ値など）にアクセスするには`${...}`形式か`<@...>`マクロを使用します。例えば、Java側で資金管理用のヘルパー関数`calculateLots()`を作っている場合、MQL4向けには以下のように関数を定義するコードを記述できます（※実際にはPseudo-codeマクロを用いる場合もありますが、わかりやすさのため直接記述の例を示します）。

```ftl
<#-- クラスレベル関数定義の例 -->
double ${snippetName}_calculateLots(double price, double sl) {
    // ロット計算ロジック（例: 口座残高に対する%リスク手法など）
    double riskAmount = AccountBalance() * ${RiskPercent} / 100.0;
    double lot = riskAmount / MathAbs(price - sl) / MarketInfo(Symbol(), MODE_TICKVALUE);
    return NormalizeDouble(lot, 2); 
}
```

上記では、`${RiskPercent}`というプレースホルダでJava側で定義されたパラメータ`RiskPercent`の値（もしくは変数名）を挿入しています。Freemarkerテンプレート内では、`${...}`で囲んだ名前がテンプレート変数（スニペットの属性を指す）であり、コード生成時にその値または名前に置き換えられます。一方、`AccountBalance()`や`MarketInfo()`はMQL4の組み込み関数であり、そのまま出力コードに含まれます。

**プレースホルダのマッピング:** Javaで定義したフィールド名・パラメータ名は、基本的にテンプレート内でも同じ名前で参照します。ただし、テンプレートでは必要に応じて**囲み文字**やマクロを用いる点に注意してください。例えば上記`${RiskPercent}`は、Java側で`public double RiskPercent;`と定義したパラメータに対応します。SQXではテンプレート内で直接`${RiskPercent}`と書けば、エクスポート時にその現在値または変数名に置き換わります（後述の`_variables.tpl`でexternとして宣言されていれば変数名、固定値ならその値）。このように、Javaのフィールドを**同名のプレースホルダ**として参照するのが基本です。万一Java側の名前が使えない場合（予約語など）はリネームを検討します。

### コード例（Java → MQL クラス定義部分）

資金管理スニペットによっては、`_class.tpl`でコードを追加しないケースもあります。例えば今回取り上げる簡単なATRボラティリティベースのロット調整では、特段のヘルパー関数を必要としないため、`_class.tpl`は空、もしくはコメント程度に留めています。複雑なロジック（例: 段階的複利やマルチシグナル連動の資金管理など）の場合には、ここで補助的な関数やデータ構造を定義しておくことで、`_method.tpl`内を簡潔に保つことができます。

**例:** 仮に「直近の最大ドローダウンに応じてリスク割合を調整する」ようなカスタム資金管理を作る場合、直近ドローダウンを記録・更新する静的変数や、その計算関数を`_class.tpl`で定義できます。そうすることで、`_method.tpl`内では単にその関数を呼び出すだけで済み、他のプラットフォーム（例: MT5や他言語）でも同様の関数をテンプレートで用意するだけで統一的に実装できます。

```cpp
// MQL4側での静的変数と関数定義の例（_class.tpl出力想定）
static double maxDrawdown = 0.0;
double adjustRiskByDrawdown(double currentDD) {
    if(currentDD > maxDrawdown) maxDrawdown = currentDD;
    // ドローダウンが増えたらリスク%を下げる等のロジック...
    double adjustedRisk = baseRiskPct * (1.0 - (maxDrawdown/100.0));
    if(adjustedRisk < 0.5) adjustedRisk = 0.5; // 下限リスク%
    return adjustedRisk;
}
```

上記は一例ですが、**`_class.tpl`にはこのようなグローバルに必要な変数や関数を記述**します。コード中の`baseRiskPct`などは、テンプレートでは`${baseRiskPct}`のように書かれ、Java側で定義したパラメータに対応します。

### ベストプラクティス（`_class.tpl`）

* **命名規則:** テンプレート内で定義する関数や変数には、**スニペット名のプレフィックス**を付けることを推奨します。例えばスニペット名が`ATRVolatilitySizing`であれば、関数名を`ATRVolatilitySizing_CalcLots`のようにしておくと、他のコードと衝突しにくくなります。SQX組み込みのコードも同様の命名で衝突を避けています。
* **必要最小限:** `_class.tpl`には必要な定義のみを書きます。MT4 EAの出力コードは一つのファイルにまとまるため、不必要な関数を増やすと可読性が落ちます。ロジックが単純であれば、`_class.tpl`を空にして`_method.tpl`内に直接ロジックを書く方が分かりやすい場合もあります。
* **他テンプレートとの連携:** `_class.tpl`で定義した関数や変数は、`_method.tpl`から使用できます。逆に、`_variables.tpl`で宣言する変数（例えばパラメータ）は`_class.tpl`内でも使えます。一貫して同じ名前を使い、定義順序に依存しないよう注意してください（SQXのコード生成では、通常`_variables.tpl`→`_class.tpl`→`_method.tpl`の順で挿入されます）。
* **プラットフォーム差異:** MQL4ではクラス定義をほぼ使いませんが、他プラットフォーム（例えばEasyLanguageなど）ではここでクラスを定義することもあります。SQXではテンプレートをプラットフォームごとに用意できるので、MQL4用テンプレートではMQL4の文法に沿った定義を行います（例えばC++風の関数定義など）。

## `_method.tpl` – ロット計算ロジックの実装

### 役割と概要

`_method.tpl`は、**資金管理スニペットの主な処理ロジック**をEA内に挿入するテンプレートです。具体的には、戦略が新規注文を発行する際に「何ロット（もしくは何数量）で発注するか」を決定するコードを提供します。Java側では`computeTradeSize(...)`というメソッドでこのロジックを実装しますが、その内容をMQL4コード上で再現するのが`_method.tpl`の役割です。EAのエントリールール実行部分（新規注文を出す`OrderSend`直前など）に、このテンプレートの出力が差し込まれることで、バックテスト時に使用した資金管理ロジックと同じ計算が実行されます。

MT4 EAの構造上、`_method.tpl`のコードは**OnTick内の注文執行ロジック**の一部として組み込まれるか、もしくはEA内の専用のポジションサイズ計算関数内で呼び出される形になります。いずれにせよ、エクスポートされたEAコードを読むと`_method.tpl`で記述した内容がそのまま見て取れるはずです。

### 構文と典型的なプレースホルダ

`_method.tpl`では、資金管理の計算式を直接MQL4の構文で記述します。この中でSQX特有のマクロも利用できますが、多くの場合**直接MQLの関数や演算子を用いて**実装します。テンプレートエンジンは、Java側スニペットからパラメータ値等を取り出す際にマクロやプレースホルダを使います。典型例として、**パラメータを参照するプレースホルダ**があります。

* `#ParameterName#`：パラメータ（Java側で@Parameter定義した変数）の値または変数名を表す特殊表記です。テンプレート内で`<@printParam block "#ParameterName#"/>`というマクロを使うと、そのパラメータが**最終コードでは数値リテラルまたは変数名**に展開されます。例えば`<@printParam block "#Size#"/>`とすれば、パラメータ`Size`がEAでextern変数として出力される設定なら`Size`（変数名）に、固定値ならその数値になります。
* `<@printInput block />`：インジケータ系ブロック用のマクロですが、資金管理では使用しません（インジケータの`iCustom`呼び出しなどでシンボル/時間枠を出力する用途）。
* MQL組み込み関数：SQX内部のJava関数呼び出しは、テンプレート上で**対応するMQL標準関数**に置き換えます。例えばJavaで`strategy.getATRValue(...)`を呼んでいるなら、MQLでは`iATR(...)`関数を使う、といった具合です。また`strategy.getBalance()`や`strategy.getEquity()`は、それぞれ`AccountBalance()`, `AccountEquity()`にマップできます。テンプレート内ではこれらMQL関数名を直接記述して問題ありません。

**プレースホルダのマッピング:** Javaコード中の識別子をMQLコードに写す際、基本的にはその名称を使います。ただし、大文字小文字や文脈に注意してください。例えばJavaの`Size`というメンバはMQLでも`Size`という変数（extern）になり得ますが、Java側でメソッド呼び出しだったものはMQLでは関数や演算式になる場合があります。先述のATRの例では、Javaでは`strategy.getATRValue(chart, period, 1)`でしたが、MQLテンプレートでは`iATR(Symbol(),0,<@printParam block "#Period#"/>,1)`のように記述し、実際のコードでは`iATR(Symbol(), 0, 14, 1)`（例えばPeriod=14の場合）となります。Pivot指標のクローン例では、テンプレート内でパラメータ名を誤って汎用名のままにしていたために正しく出力されず、`#Param1#`を`#StartHour#`に修正する必要があったという指摘があります。このように、**テンプレート中のプレースホルダがJava側の正しいフィールド名を参照していること**が重要です。

### コード例（Javaのスニペット → テンプレート → MQL出力）

ここでは、具体例としてATRボラティリティによるロット調整スニペット（ATR Volatility Sizing）の**Javaコード**と、そこから生成される**MQL4コード**を比較します。Java側の`computeTradeSize`メソッドでは、「直近の短期ATRと長期ATRを比較し、短期の方が大きければロットを倍増、それ以外はデフォルトサイズ」というシンプルなロジックを実装しています。

**Java側の`computeTradeSize`メソッドの例:**（抜粋）

```java
double tradeSize;
// 直近の終値取得（未使用だが例示）
double prevClose = strategy.MarketData.Chart(symbol).Close(1); 
// 長期ATR値（SlowATRPeriod）の取得と丸め込み
double slowValueATR = SQUtils.round(
    strategy.getATRValue(strategy.MarketData.Chart(symbol), SlowATRPeriod, 1), 5);
// 短期ATR値（FastATRPeriod）の取得と丸め込み
double fastValueATR = SQUtils.round(
    strategy.getATRValue(strategy.MarketData.Chart(symbol), FastATRPeriod, 1), 5);
// 短期ボラティリティが高ければロット倍率を変更
if (fastValueATR > slowValueATR) {
    tradeSize = Size * Multiplier;
} else {
    tradeSize = Size;
}
return tradeSize;
```

上記Javaコードに対応するMQL4コードを、テンプレートによって生成すると以下のようになります。

**MQL4側のコード（テンプレート適用結果）例:**

```cpp
// ATRボラティリティ資金管理のロット計算（MT4 EA内）
double slowValueATR = iATR(Symbol(), 0, SlowATRPeriod, 1);
double fastValueATR = iATR(Symbol(), 0, FastATRPeriod, 1);
double lotSize;
if (fastValueATR > slowValueATR) {
    lotSize = Size * Multiplier;
} else {
    lotSize = Size;
}
// ロットをブローカーの最小単位に調整
lotSize = MathFloor(lotSize / MarketInfo(Symbol(), MODE_LOTSTEP)) 
           * MarketInfo(Symbol(), MODE_LOTSTEP);
// 最終的な発注ロット数に設定
lots = lotSize;
```

上記のように、Javaのコード内で呼び出していた`strategy.getATRValue`は、MQLでは`iATR`という組み込み関数に置き換えられています。また`Size`や`Multiplier`といったパラメータは、EAコードではグローバル変数（後述の`_variables.tpl`でexternとして宣言）として扱われているため、そのまま`Size`や`Multiplier`という名前で参照できます。テンプレートではこれらを`${Size}`や`${Multiplier}`のようなプレースホルダで表現し、コード生成時に適切に展開されます。

なお、上記MQLコードではロット数`lotSize`を計算した後に**ブローカーのロットステップ**に合わせて調整しています。これは、例えば最小ロット単位が0.01のときに0.015のような値が出た場合、下位に切り捨てて0.01に揃える処理です。SQXのJava環境では`sizeStep`パラメータ（computeTradeSizeの引数）やユーティリティを用いてこの調整を行いますが、MQL側でも同様の処理を入れるのが望ましいです（上の例では`MathFloor`と`MarketInfo(..., MODE_LOTSTEP)`で実装）。このような微調整もテンプレートに織り込むことで、**バックテスト時の値と実際のEA執行時の値を一致**させることができます。

### ベストプラクティス & 注意点（`_method.tpl`）

* **計算精度と丸め:** ロット計算では浮動小数点演算となるため、必要に応じて`NormalizeDouble`や上記のようなステップ調整を行い、ブローカーの許容する桁数・単位に合わせます。特にリスク%に基づく計算では、`AccountBalance()`/`AccountEquity()`や`MarketInfo(Symbol(), MODE_TICKVALUE)`等を使って算出した値を**適切に丸め処理**することが重要です。
* **動的SL/TPへの対応:** 資金管理ロジックがストップロス値に依存する場合（例: リスク○%手法ではSL距離でロット計算）、テンプレート内で**必ずSL価格またはピップスに基づく計算**を再現してください。Javaスニペットでは`computeTradeSize`の引数`sl`にストップロス価格が渡されます。MQLでは`OrderSend`前に設定したSL価格との差（ピップス）からロットを求める必要があります。例えば`riskLot = (AccountEquity()*RiskPercent/100) / ((price - sl) * pointValue)`のように、口座リスク額を価格差×ポイント価値で割る計算です。テンプレートでこの計算を誤ると、エクスポートEAでは常に固定ロットになってしまう等の不具合が起こり得ます（実際、あるユーザは「%リスク」がMT4 EAで機能せず常に固定ロットになる問題を報告しています）。
* **コードの挿入位置:** `_method.tpl`の内容がEAのどこに組み込まれるかを念頭に置きましょう。一般には**新規注文を出す直前**にこのコードが挿入され、計算結果のロットサイズを変数にセットする流れになります。EAのテンプレートによっては、内部で`CalculatePositionSize()`のような関数を呼ぶ構造になっており、その中身として`_method.tpl`が展開される場合もあります。いずれの場合も、最終的に計算されたロットをEAが実際の発注に使う変数へ代入することを忘れないでください（上記コード例では`lots`という変数に`lotSize`を代入しています）。この`lots`はEA内で発注時に参照される変数です（EAのベースコードで定義済みの場合があります）。自作テンプレートでは、このような\*\*既存のEAコードとのインタフェース（変数名や呼び出し）\*\*を正しく把握して記述する必要があります。
* **変数のスコープ:** `_method.tpl`内で用いるパラメータ変数（Size, Multiplierなど）は`_variables.tpl`で宣言されている前提です。テンプレート編集時には、それらが**グローバル変数として存在する**ものとみなしてコードを書きます。仮に同名の局所変数をここで宣言してしまうと、グローバルな値が参照されず正しく機能しません。また、`_class.tpl`で定義した関数や変数を使う場合も、適切にスコープを指定（グローバル変数ならそのまま、クラス内のstaticメソッドなら`ClassName::method()`形式など）するようにします。もっとも、MT4 EAではシンプルにすべてグローバルスコープなので深く考える必要はない場合が多いでしょう。
* **他の要素との干渉:** 資金管理ロジックは基本的にロット数決定だけですが、EA全体ではこの後に**注文発行**や**他のリスク管理**（同時ポジション制限など）が続きます。テンプレートで書いたロジックがこれらと矛盾しないように注意します。例えば、計算したロットが0になるケース（残高が小さい等）ではOrderSendをスキップする処理がEA側になければ、注文が出ないまま戦略が動くことになります。必要であれば、`if(lots < 最小ロット) return;`のようなガードコードも`_method.tpl`に加えることを検討してください。

## `_variables.tpl` – パラメータ・変数宣言の定義

### 役割と概要

`_variables.tpl`は、資金管理スニペットで使用する**各種パラメータや変数を宣言するコード**を提供するテンプレートです。このテンプレートの内容は、EAコードのグローバルセクション（ファイル先頭付近）に挿入されます。具体的には、Java側で`@Parameter`アノテーションを付けたフィールドや、スニペット内部で使用する定数・変数をここでMQL4の**グローバル変数**として宣言します。多くの場合、@Parameterで定義したものはユーザーがEAのパラメータ入力で変更できるよう`extern`（もしくはMT5なら`input`）変数になります。

### 構文とプレースホルダの使い方

テンプレート内では、基本的に「型 名 = 初期値;」という宣言文を出力します。SQXのテンプレートマクロを使って、この宣言文を自動生成することもできますし、必要に応じて手書きして`${...}`で値を挿入することも可能です。

例えば、Java側で以下のようにパラメータが定義されていたとします。

```java
@Parameter(defaultValue="0.1", name="Order size", ... )
public double Size;

@Parameter(defaultValue="0.1", name="Multiplier", ... )
public double Multiplier;

@Parameter(defaultValue="5", name="Fast ATR Period", ... )
public int FastATRPeriod;

@Parameter(defaultValue="20", name="Slow ATR Period", ... )
public int SlowATRPeriod;
```

上記4つのパラメータは、それぞれ**注文ロット初期値**, **ロット倍率**, **短期ATR期間**, **長期ATR期間**を表します。`_variables.tpl`では、これらに対応するMQL4コードを出力します。典型的には次のようになります。

```cpp
extern double Size = 0.1;         // Order size (number of lots for forex)
extern double Multiplier = 0.1;   // Multiplier for lot sizing
extern int    FastATRPeriod = 5;  // Fast ATR Period
extern int    SlowATRPeriod = 20; // Slow ATR Period
```

このように、Java側の型に合わせてMQL4の型（double→double, int→int）を使用し、デフォルト値もJavaのdefaultValueに合わせています。テンプレート上では、例えば`extern double ${Name} = ${DefaultValue};`のように記述し、SQXが持つスニペットメタ情報からNameやDefaultValueを取り出すことができます。SQXでは`#Name#`や`#DefaultValue#`のようなマクロが用意されている場合があります（内部的にはFreemarkerのデータモデル経由でアクセス）。自作テンプレートでは、単純にJava側と同じ値を埋め込むだけなら手動で書いてしまっても構いませんが、できればSQXの用意する変数を使って自動化するとミスが減ります。

なお、資金管理によっては**パラメータではない内部変数**を必要とすることもあります。例えばマーチンゲール法で前回負けかどうかを保持するフラグや、複利運用で累積利益を保持する変数などです。その場合、Javaコード中でフィールドとして定義していれば同様にここで宣言すればよいですし、計算上のみ必要な場合は`_method.tpl`内で局所変数として扱うこともあります。**状態を保持する必要があるものはEA内で静的またはグローバル変数にする**必要がありますので、忘れずに`_variables.tpl`に追加します。

### コード例（Javaパラメータ → MQL変数宣言）

上記のJavaパラメータ定義に対して、`_variables.tpl`で出力されるMQL4コードの一例を再掲します。

```cpp
extern double Size = 0.1;         // 初期ロット数
extern double Multiplier = 0.1;   // ロット倍率
extern int    FastATRPeriod = 5;  // 短期ATR期間
extern int    SlowATRPeriod = 20; // 長期ATR期間
```

ここではそれぞれの変数にコメントも付け、役割を明示しています。テンプレート内でコメントを含めることも可能です（自由テキストとして書けばそのまま出力されます）。特に複数の資金管理パラメータがある場合、EA利用者が混乱しないようコメントや名称で意味を伝えることが重要です。

**プレースホルダのマッピング:** 基本的に、Java側で`public double XYZ;`とあればテンプレートでも`XYZ`という名前で参照します。デフォルト値も文字列として与えられている場合、それを数値にキャストする必要があります（多くの場合SQXが適切な型にしてくれます）。上の例では`defaultValue="0.1"`が文字列ですが、テンプレートでは`${DefaultValue}`が`0.1`の数値として扱われます。仮に文字列で渡る場合は適宜変換してください。プレースホルダ`${Name}`はフィールド名（例: `Size`）を表し、それをそのままコード上の変数名に使っています。万が一変数名が他と衝突しそうな場合は、ここでリネームすることもできます（例えば`${StrategyName}_${Name}`のように戦略名やスニペット名を付与する）。しかし通常は衝突しないようユニークな名前を付けているはずなので、そのままで問題ありません。

### ベストプラクティス & 注意点（`_variables.tpl`）

* **命名と一貫性:** EA内の全グローバル変数でユニークな名前になるよう心がけます。資金管理パラメータは他の指標パラメータ等と被りにくい名前（例えば単なる`Period`ではなく`FastATRPeriod`のように具体的な名前）にします。SQX標準の組み込みスニペットも、汎用的な用語には接頭辞を付けるなど工夫しています。名前が衝突するとコンパイルエラーになるか、意図しない値を参照する原因になります。
* **データ型の整合:** Javaでは`double`だったものをMQL側でも`double`にするのは当然ですが、注意すべきは**整数と実数の違い**です。例えば`int Lots`のように整数型で定義したパラメータを、そのままMQLの`int`にすると小数ロットを扱えなくなります。資金管理ではロットは通常小数なので、Java側でintにしていた場合でもMQLでは`double`にすべきケースがあります（ただし株数など整数でしか指定しない資産ならintでOKです）。SQXでパラメータを定義する際に適切な型を選んでいれば問題ありませんが、テンプレート実装者はその意図を汲んで型を決めてください。
* **初期値の単位:** デフォルト値を設定する際、その単位に注意します。例えば%を表すパラメータなら100ではなく0-100の範囲でしょうし、ピップスではなく価格差そのものの場合もあります。Java側のdefaultValueを鵜呑みにせず、EAでの使われ方に照らして妥当か確認します。コメントにも単位や意味を記述しておくとよいでしょう。
* **静的変数の利用:** 資金管理によっては、パラメータではない**静的なカウンタ**や**フラグ**を保持したいことがあります。例えばマーチンゲールの連敗カウントなどです。そうした場合、MQLでは`static`変数としてOnTick間で値を保持できます。テンプレートで`static int lossCount = 0;`のように宣言しておけば、EA内でグローバルに配置されます。Java側でそのような変数がStrategyBase経由などで保持されている場合は、忘れずにMQL側にも用意します。
* **テンプレート不足の対処:** `_variables.tpl`は3つのテンプレートの中でも忘れられがちですが、**欠けているとコード生成エラーになります**。実際、カスタムスニペットを作成後にMT4用EAを保存しようとした際、「テンプレートが見つからない」というエラーが出る場合は、このファイル名の綴り間違いや配置ミスが原因のことがあります。ファイル名は\*\*`<クラス名>_variables.tpl`\*\*とし、他の2つ（\_class.tpl, \_method.tpl）とともに所定のフォルダに置かれているか確認してください。

## MT4 EAコードへの統合とエクスポート時の注意

最後に、これら3つのテンプレートファイルがMT4 EAコード全体の中でどのように組み込まれるかを説明します。また、StrategyQuantからEAをエクスポートする際の統合上の注意点も述べます。

### テンプレート挿入位置とEAコード構造

SQXが出力するMT4用EAは、概ね以下のような構造を持っています（Pseudo-code形式）:

1. **インクルードとグローバル設定** – `#include`文や`#property`文、およびグローバル変数の宣言。
2. **グローバル変数宣言** – **`_variables.tpl`の内容**がここに挿入されます。資金管理のみならず、インジケータのパラメータなど他のスニペットの変数宣言もこのブロックに続きます。
3. **カスタム関数・クラス定義** – **`_class.tpl`の内容**は通常この位置に入ります。必要な関数や静的変数があればここで定義され、以降のコードから利用可能になります。
4. **EAの初期化コード (OnInit)** – 必要に応じて初期化処理。資金管理では特にありませんが、例えばカスタムインディケータを読み込む場合などに出力されることがあります。
5. **EAのメイン処理 (OnTick)** – 戦略の売買ロジックを実行する部分です。ここでエントリー条件をチェックし、満たせば注文発行コードへ進みます。発注時にロット数を決定する箇所で\*\*`_method.tpl`の内容\*\*が展開されます。具体的には、新規注文を出す直前に`lots`変数を計算するブロックとして挿入されます（もしくは`CalculateLots()`関数の中身として挿入され、その関数がOnTick内で呼ばれる形）。
6. **その他の関数 (OnDeinit, 補助関数)** – 終了処理やTrailing Stopの処理、取引管理用の補助関数群が続くことがあります。資金管理スニペット自体は関与しませんが、例えばトレーリングストップの処理内でポジションサイズに依存するロジックがある場合、その部分にも影響が及ばないか確認しておくとよいでしょう。

以上のように、各.tplファイルはEAコード内の適切な場所に差し込まれます。エクスポートされたEAのソースコードを閲覧すると、自分が書いたテンプレート内容が反映されていることを確認できます。特にトラブルシューティング時には、この出力コードを読むことが有用です。例えば、パラメータの値がおかしい、計算結果が合わないといった場合、**出力されたMQLコード上で**問題箇所（テンプレート由来のコード）を探せば原因が分かるでしょう。

### エクスポート時の留意点

* **テンプレートの作成と追加:** カスタム資金管理スニペットを作成した後、忘れずに「Add all missing templates」（すべての不足テンプレートを追加）機能を使って、各プラットフォーム用のテンプレートを生成してください。SQXのコードエディタでスニペットを右クリックし、このオプションを選ぶとMT4用の`_class.tpl`, `_method.tpl`, `_variables.tpl`が自動的に雛形作成されます。雛形では汎用的なコードやダミーのプレースホルダが入っているため、それを参考に実際のロジックに合わせて編集します。
* **テンプレート配置:** 作成した.tplファイルはSQXの内部ディレクトリ構造上適切な場所に保存する必要があります。通常、ユーザーが追加したスニペットは`User/Code/`以下（もしくは`internal/extend/Code/`以下）の該当カテゴリーのフォルダ（MoneyManagement）に配置されます。ファイル名は**スニペットのクラス名と一致**させます（大文字小文字も含めて一致させること）。例えば`ATRVolatilitySizing.java`というクラスなら、`ATRVolatilitySizing_class.tpl`等となります。名前不一致や場所誤りはエクスポート時のエラーにつながります。エラー例:「One or more blocks the strategy uses isn’t implemented in MQL code – Template inclusion failed...」は、まさに対応テンプレートが見つからない場合に出るメッセージです。
* **エクスポートオプションの確認:** SQXの「結果→ソースコード」タブでEAコードを生成する際、使用する資金管理モデルを選択できます。通常はバックテストに使ったものが選ばれますが、別の資金管理に差し替えることも可能です。そのため、自作の資金管理を正しく出力させるには、**自作スニペットを選択**してエクスポートする必要があります。選択ミスに注意しましょう。
* **コンパイルとテスト:** 出力されたEAコードは、MetaEditorでコンパイルしてエラーがないか確認します。テンプレートのミスでコンパイルエラーが起きる場合、例えば「undeclared identifier」「syntax error」などのメッセージが出ます。該当行を見てテンプレートを修正してください。コンパイルが通ったら、ストラテジーテスター等でバックテストし、SQX上のシミュレーション結果と一致するか検証します。ロット計算が正しく反映されているか、境界条件でもおかしな動きをしないか（例: 残高増減に応じてロットが意図通り変化するか）を確認します。不一致があれば再度テンプレートかロジックを見直します。
* **他プラットフォームへの展開:** 本ガイドはMT4(MQL4)への変換を扱いましたが、SQXではMT5や他プラットフォーム（Tradestation等）用にもテンプレートを用意できます。基本的な考え方は同じです。プラットフォーム固有の違い（例: MT5では`input`キーワードを使う、など）に留意しつつ、それぞれ実装してください。すべてのプラットフォームにテンプレートがないと、片方（例えばMT5）でのみエラーになるということも起こり得ます。必要に応じて複数環境でテストしましょう。

以上、StrategyQuantのJavaベース資金管理スニペットをMT4 EA対応のMQLコードへ変換する手順とポイントについて解説しました。適切に`_class.tpl`, `_method.tpl`, `_variables.tpl`を作成すれば、バックテストで開発・検証したマネーマネジメント戦略をそのままMT4のEAに組み込むことができます。テンプレート編集には多少の習熟が要りますが、本ガイドの例やSQXコードベースの他の例を参考に進めれば、効率的に実装できるでしょう。最後に、コード生成後は十分なテストを行い、ロット計算や資金管理ロジックが期待通り機能することを確認してください。これで、自作の資金管理手法を含むEAを安心して運用できるようになります。

**参考資料:** StrategyQuant公式ドキュメントおよびフォーラムより、テンプレートの仕組みとカスタムスニペット実装に関する情報を参照しました。各種コード例はATRボラティリティ・サイズ調整の実装を基に作成しています。
